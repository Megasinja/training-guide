<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spectral Clustering シミュレータ</title>
  <style>
    :root {
      --bg:#081326;
      --panel:#0f1f3e;
      --text:#e9efff;
      --muted:#aab8de;
      --line:#2b406e;
      --warn:#ffd06b;
      --good:#67d79a;
      --bad:#ff8787;
      --accent:#73a7ff;
    }

    * { box-sizing:border-box; }

    body {
      margin:0;
      min-height:100vh;
      color:var(--text);
      font-family:"Hiragino Sans", "Noto Sans JP", "Yu Gothic", sans-serif;
      background:
        radial-gradient(circle at 12% 14%, rgba(115,167,255,0.17), transparent 34%),
        radial-gradient(circle at 88% 10%, rgba(111,223,167,0.16), transparent 28%),
        linear-gradient(180deg, #060f1d, var(--bg));
    }

    .top-nav {
      max-width:1220px;
      margin:14px auto 0;
      padding:0 18px;
      display:flex;
      gap:14px;
      flex-wrap:wrap;
    }

    .top-link {
      color:var(--muted);
      text-decoration:none;
      font-size:13px;
    }

    .top-link:hover {
      color:var(--text);
      text-decoration:underline;
    }

    .wrap {
      max-width:1220px;
      margin:0 auto;
      padding:16px 18px 24px;
      display:grid;
      grid-template-columns:1.22fr 0.78fr;
      gap:16px;
    }

    .card {
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.09);
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding:14px;
      box-shadow:0 15px 32px rgba(0,0,0,0.35);
    }

    h1 {
      margin:0 0 8px;
      font-size:19px;
      line-height:1.35;
    }

    .sub {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.65;
    }

    .pill {
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.13);
      background:rgba(255,255,255,0.05);
      color:var(--muted);
      font-size:12px;
    }

    .formula {
      margin-top:10px;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(8,16,32,0.52);
      padding:9px;
      color:#dce5ff;
      font-size:12px;
      line-height:1.6;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }

    .desc {
      margin-top:10px;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(255,255,255,0.03);
      padding:9px;
      font-size:12px;
      line-height:1.6;
      color:#d4deff;
    }

    canvas {
      width:100%;
      height:auto;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(4,10,24,0.45);
    }

    .legend {
      margin-top:9px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      font-size:12px;
      color:var(--muted);
    }

    .dot {
      display:inline-block;
      width:10px;
      height:10px;
      border-radius:50%;
      margin-right:6px;
      vertical-align:middle;
    }

    .mini-title {
      margin:12px 0 7px;
      font-size:13px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .row {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    button {
      cursor:pointer;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      font-size:13px;
      padding:8px 10px;
      transition:background .2s ease;
    }

    button:hover { background:rgba(255,255,255,0.11); }

    button.primary {
      border-color:rgba(115,167,255,0.58);
      background:rgba(115,167,255,0.21);
    }

    button.primary:hover { background:rgba(115,167,255,0.28); }

    .selectrow {
      display:grid;
      grid-template-columns:120px 1fr;
      gap:10px;
      margin:8px 0;
      align-items:center;
      font-size:13px;
    }

    select {
      width:100%;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      padding:7px 8px;
      font-size:13px;
    }

    .slider {
      margin:10px 0;
      display:grid;
      grid-template-columns:140px 1fr 84px;
      gap:10px;
      align-items:center;
      font-size:13px;
    }

    input[type="range"] { width:100%; accent-color:#75a8ff; }

    .checkrow {
      margin:8px 0;
      color:var(--muted);
      font-size:13px;
      display:flex;
      align-items:center;
      gap:8px;
    }

    .hr {
      height:1px;
      margin:12px 0;
      background:rgba(255,255,255,0.11);
    }

    .kv {
      display:grid;
      grid-template-columns:1fr auto;
      gap:8px 10px;
      font-size:13px;
    }

    .kv div:nth-child(odd) { color:var(--muted); }

    .status {
      margin-top:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(0,0,0,0.2);
      padding:10px;
      font-size:13px;
      line-height:1.55;
    }

    .status.good {
      border-color:rgba(103,215,154,0.52);
      background:rgba(103,215,154,0.12);
    }

    .status.warn {
      border-color:rgba(255,208,107,0.52);
      background:rgba(255,208,107,0.12);
    }

    .detail {
      margin-top:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(2,8,20,0.55);
      padding:8px;
      color:#d8e2ff;
      font-size:12px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      max-height:180px;
      overflow:auto;
    }

    @media (max-width: 990px) {
      .wrap { grid-template-columns:1fr; }
      .slider { grid-template-columns:112px 1fr 84px; }
      .selectrow { grid-template-columns:100px 1fr; }
    }
  </style>
</head>
<body>
  <div class="top-nav">
    <a class="top-link" href="clustering-hub.html">← クラスタリングハブへ戻る</a>
    <a class="top-link" href="index.html">研修トップへ戻る</a>
  </div>

  <div class="wrap">
    <section class="card">
      <h1>Spectral Clustering シミュレータ</h1>
      <p class="sub">
        類似度グラフを作り、ラプラシアンの固有ベクトル空間へ埋め込んでからクラスタ分割します。
        非凸形状にも対応しやすいのが特徴です。
      </p>

      <div class="formula">類似度
W_ij = exp(-||x_i-x_j||² / (2σ²))  (k近傍のみ接続)

正規化
D_ii = Σ_j W_ij
S = D^{-1/2} W D^{-1/2}

埋め込み
U = top-K eigenvectors of S
Y_i = U_i / ||U_i||

クラスタ割当
Y 上で K-means</div>

      <div class="desc">
        <b>パラメータ説明</b><br>
        `k近傍` はグラフの疎密、`σ` は類似度減衰、`K` は最終クラスタ数です。
        `反復回数/step` は固有ベクトル近似（直交反復）の更新量です。
      </div>

      <canvas id="plot" width="860" height="500"></canvas>
      <div class="legend" id="legend"></div>

      <div class="mini-title">
        <span>スペクトル埋め込み（Uの先頭2次元）</span>
        <span class="pill" id="modePill">モード: 学習中</span>
      </div>
      <canvas id="embedPlot" width="860" height="220"></canvas>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <div style="font-size:14px; font-weight:700;">操作パネル</div>
        <div class="pill" id="statePill">状態: 計算中</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="primary" id="btnPlay">再生</button>
        <button id="btnPause">停止</button>
        <button id="btnStep">1ステップ</button>
        <button id="btnReset">埋め込み初期化</button>
        <button id="btnNew">データ再生成</button>
      </div>

      <div class="hr"></div>

      <div class="selectrow">
        <div>データ形状</div>
        <select id="datasetType">
          <option value="blobs">ガウス塊</option>
          <option value="rings">同心円</option>
          <option value="moons">2つの月</option>
        </select>
      </div>

      <div class="slider">
        <div>K（クラスタ数）</div>
        <input id="kRange" type="range" min="2" max="8" step="1" value="3" />
        <div id="kVal">3</div>
      </div>

      <div class="slider">
        <div>k近傍</div>
        <input id="knnRange" type="range" min="2" max="30" step="1" value="10" />
        <div id="knnVal">10</div>
      </div>

      <div class="slider">
        <div>類似度 σ</div>
        <input id="sigmaRange" type="range" min="0.10" max="2.20" step="0.01" value="0.80" />
        <div id="sigmaVal">0.80</div>
      </div>

      <div class="slider">
        <div>反復回数/step</div>
        <input id="iterRange" type="range" min="1" max="8" step="1" value="2" />
        <div id="iterVal">2</div>
      </div>

      <div class="slider">
        <div>更新/秒</div>
        <input id="speedRange" type="range" min="1" max="20" step="1" value="4" />
        <div id="speedVal">4</div>
      </div>

      <div class="slider">
        <div>点の数</div>
        <input id="countRange" type="range" min="20" max="160" step="2" value="84" />
        <div id="countVal">84</div>
      </div>

      <div class="slider">
        <div>生成クラスタ数</div>
        <input id="trueKRange" type="range" min="2" max="8" step="1" value="3" />
        <div id="trueKVal">3</div>
      </div>

      <div class="slider">
        <div>クラス間隔</div>
        <input id="sepRange" type="range" min="0.6" max="3.8" step="0.1" value="2.2" />
        <div id="sepVal">2.2</div>
      </div>

      <div class="slider">
        <div>ノイズ σ</div>
        <input id="noiseRange" type="range" min="0.03" max="1.20" step="0.01" value="0.30" />
        <div id="noiseVal">0.30</div>
      </div>

      <label class="checkrow"><input id="showGraph" type="checkbox" checked /> 近傍グラフの辺を表示</label>

      <div class="hr"></div>

      <div class="kv">
        <div>ステップ</div><div id="stepVal">0</div>
        <div>グラフ辺数</div><div id="edgeVal">-</div>
        <div>埋め込み移動量</div><div id="shiftVal">-</div>
        <div>割当変化数</div><div id="changeVal">-</div>
        <div>埋め込み内 Inertia</div><div id="inertiaVal">-</div>
      </div>

      <div id="statusBox" class="status">評価: 初期化中...</div>
      <div class="detail" id="detailBox">-</div>
    </section>
  </div>

  <script>
  (() => {
    function randn() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function clamp(v, lo, hi) {
      return Math.min(hi, Math.max(lo, v));
    }

    function sqDist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return dx * dx + dy * dy;
    }

    const palette = [
      [115, 167, 255],
      [255, 125, 125],
      [126, 226, 168],
      [255, 211, 109],
      [213, 155, 255],
      [135, 220, 255],
      [255, 168, 107],
      [145, 161, 255]
    ];

    function colorOf(id, alpha) {
      const c = palette[id % palette.length];
      return `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;
    }

    function generateData(type, count, sep, noise, trueK) {
      const points = [];
      for (let i = 0; i < count; i += 1) {
        const group = i % trueK;
        let x;
        let y;

        if (type === 'blobs') {
          const r = sep * 1.15 + 0.5;
          const a = (Math.PI * 2 * group) / trueK;
          x = r * Math.cos(a) + randn() * noise;
          y = 0.8 * r * Math.sin(a) + randn() * noise;
        } else if (type === 'rings') {
          const minR = 0.7;
          const ringGap = 0.55 + sep * 0.24;
          const radius = minR + group * ringGap;
          const t = Math.random() * Math.PI * 2;
          x = radius * Math.cos(t) + randn() * noise;
          y = radius * Math.sin(t) + randn() * noise;
        } else {
          const label = i < count / 2 ? 0 : 1;
          const t = Math.random() * Math.PI;
          if (label === 0) {
            x = Math.cos(t);
            y = Math.sin(t);
          } else {
            x = 1 - Math.cos(t);
            y = -Math.sin(t) - 0.5;
          }
          const sc = 2.0 + sep * 0.34;
          x = (x - 0.55) * sc + (label === 0 ? -sep * 0.2 : sep * 0.2);
          y = (y - 0.08) * sc;
          x += randn() * noise;
          y += randn() * noise;
        }

        points.push({ x: clamp(x, -4, 4), y: clamp(y, -4, 4), group, cluster: -1 });
      }
      return points;
    }

    const plot = document.getElementById('plot');
    const pctx = plot.getContext('2d');
    const embedPlot = document.getElementById('embedPlot');
    const ectx = embedPlot.getContext('2d');

    const datasetType = document.getElementById('datasetType');
    const kRange = document.getElementById('kRange');
    const knnRange = document.getElementById('knnRange');
    const sigmaRange = document.getElementById('sigmaRange');
    const iterRange = document.getElementById('iterRange');
    const speedRange = document.getElementById('speedRange');
    const countRange = document.getElementById('countRange');
    const trueKRange = document.getElementById('trueKRange');
    const sepRange = document.getElementById('sepRange');
    const noiseRange = document.getElementById('noiseRange');
    const showGraph = document.getElementById('showGraph');

    let points = [];
    let W = [];
    let S = [];
    let edges = [];
    let edgeCount = 0;

    let Q = [];
    let Y = [];
    let centroids = [];
    let assignments = [];

    let running = true;
    let stepCount = 0;
    let metrics = {
      shift: 0,
      changed: 0,
      inertia: 0,
      edgeCount: 0
    };

    let lastUpdate = null;

    let lastT = performance.now();
    let accMs = 0;

    function sliders() {
      return {
        type: datasetType.value,
        k: parseInt(kRange.value, 10),
        knn: parseInt(knnRange.value, 10),
        sigma: parseFloat(sigmaRange.value),
        iter: parseInt(iterRange.value, 10),
        speed: parseInt(speedRange.value, 10),
        count: parseInt(countRange.value, 10),
        trueK: parseInt(trueKRange.value, 10),
        sep: parseFloat(sepRange.value),
        noise: parseFloat(noiseRange.value)
      };
    }

    function updateLegend() {
      const k = sliders().k;
      const out = [];
      for (let i = 0; i < k; i += 1) {
        out.push(`<span><span class="dot" style="background:${colorOf(i, 0.95)}"></span>cluster ${i}</span>`);
      }
      out.push('<span><span class="dot" style="background:rgba(255,255,255,0.8)"></span>近傍グラフ辺</span>');
      document.getElementById('legend').innerHTML = out.join('');
    }

    function buildGraph() {
      const s = sliders();
      const n = points.length;
      const knn = Math.min(Math.max(1, s.knn), Math.max(1, n - 1));
      const sigma2 = Math.max(1e-6, s.sigma * s.sigma);

      W = new Array(n);
      for (let i = 0; i < n; i += 1) W[i] = new Array(n).fill(0);

      const dist = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const arr = [];
        for (let j = 0; j < n; j += 1) {
          if (i === j) continue;
          arr.push({ j, d2: sqDist(points[i], points[j]) });
        }
        arr.sort((a, b) => a.d2 - b.d2);
        dist[i] = arr;
      }

      const knnSet = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const sset = new Set();
        for (let t = 0; t < knn; t += 1) sset.add(dist[i][t].j);
        knnSet[i] = sset;
      }

      edges = [];
      edgeCount = 0;
      for (let i = 0; i < n; i += 1) {
        for (let j = i + 1; j < n; j += 1) {
          const linked = knnSet[i].has(j) || knnSet[j].has(i);
          if (!linked) continue;
          const d2 = sqDist(points[i], points[j]);
          const w = Math.exp(-d2 / (2 * sigma2));
          W[i][j] = w;
          W[j][i] = w;
          edges.push([i, j, w]);
          edgeCount += 1;
        }
      }

      const D = new Array(n).fill(0);
      for (let i = 0; i < n; i += 1) {
        let ssum = 0;
        for (let j = 0; j < n; j += 1) ssum += W[i][j];
        D[i] = ssum;
      }

      S = new Array(n);
      for (let i = 0; i < n; i += 1) {
        S[i] = new Array(n).fill(0);
        for (let j = 0; j < n; j += 1) {
          const den = Math.sqrt(Math.max(1e-12, D[i] * D[j]));
          S[i][j] = den > 0 ? W[i][j] / den : 0;
        }
      }
    }

    function randomQ() {
      const n = points.length;
      const k = sliders().k;
      Q = new Array(n);
      for (let i = 0; i < n; i += 1) {
        Q[i] = new Array(k);
        for (let j = 0; j < k; j += 1) Q[i][j] = randn();
      }
      orthonormalizeCols(Q);
      Y = rowNormalize(Q);
    }

    function matMulS(X) {
      const n = S.length;
      const k = X[0].length;
      const Z = new Array(n);
      for (let i = 0; i < n; i += 1) {
        const row = new Array(k).fill(0);
        for (let j = 0; j < n; j += 1) {
          const sij = S[i][j];
          if (sij === 0) continue;
          for (let c = 0; c < k; c += 1) {
            row[c] += sij * X[j][c];
          }
        }
        Z[i] = row;
      }
      return Z;
    }

    function orthonormalizeCols(M) {
      const n = M.length;
      const k = M[0].length;
      const cols = new Array(k);

      for (let c = 0; c < k; c += 1) {
        const v = new Array(n);
        for (let i = 0; i < n; i += 1) v[i] = M[i][c];

        for (let p = 0; p < c; p += 1) {
          let dot = 0;
          for (let i = 0; i < n; i += 1) dot += v[i] * cols[p][i];
          for (let i = 0; i < n; i += 1) v[i] -= dot * cols[p][i];
        }

        let norm = 0;
        for (let i = 0; i < n; i += 1) norm += v[i] * v[i];
        norm = Math.sqrt(Math.max(1e-12, norm));
        for (let i = 0; i < n; i += 1) v[i] /= norm;

        cols[c] = v;
      }

      for (let i = 0; i < n; i += 1) {
        for (let c = 0; c < k; c += 1) M[i][c] = cols[c][i];
      }
    }

    function rowNormalize(M) {
      const n = M.length;
      const k = M[0].length;
      const out = new Array(n);
      for (let i = 0; i < n; i += 1) {
        let norm = 0;
        for (let c = 0; c < k; c += 1) norm += M[i][c] * M[i][c];
        norm = Math.sqrt(Math.max(1e-12, norm));
        out[i] = new Array(k);
        for (let c = 0; c < k; c += 1) out[i][c] = M[i][c] / norm;
      }
      return out;
    }

    function distVec(a, b) {
      let s = 0;
      for (let i = 0; i < a.length; i += 1) {
        const d = a[i] - b[i];
        s += d * d;
      }
      return s;
    }

    function initKmeans() {
      const n = Y.length;
      const k = sliders().k;
      centroids = [];
      assignments = new Array(n).fill(0);

      const used = new Set();
      for (let i = 0; i < k; i += 1) {
        let idx = Math.floor(Math.random() * n);
        while (used.has(idx) && used.size < n) idx = Math.floor(Math.random() * n);
        used.add(idx);
        centroids.push(Y[idx].slice());
      }

      for (let i = 0; i < points.length; i += 1) points[i].cluster = 0;
    }

    function kmeansStep() {
      const n = Y.length;
      const k = centroids.length;
      const prev = assignments.slice();
      let changed = 0;
      let inertia = 0;

      for (let i = 0; i < n; i += 1) {
        let best = 0;
        let bestD = Infinity;
        for (let c = 0; c < k; c += 1) {
          const d = distVec(Y[i], centroids[c]);
          if (d < bestD) {
            bestD = d;
            best = c;
          }
        }
        assignments[i] = best;
        if (prev[i] !== best) changed += 1;
        inertia += bestD;
      }

      const dim = centroids[0].length;
      const next = new Array(k);
      const cnt = new Array(k).fill(0);
      for (let c = 0; c < k; c += 1) next[c] = new Array(dim).fill(0);

      for (let i = 0; i < n; i += 1) {
        const c = assignments[i];
        cnt[c] += 1;
        for (let d = 0; d < dim; d += 1) next[c][d] += Y[i][d];
      }

      let move = 0;
      for (let c = 0; c < k; c += 1) {
        if (cnt[c] === 0) {
          const idx = Math.floor(Math.random() * n);
          next[c] = Y[idx].slice();
        } else {
          for (let d = 0; d < dim; d += 1) next[c][d] /= cnt[c];
        }
        move += Math.sqrt(distVec(next[c], centroids[c]));
      }

      centroids = next;

      for (let i = 0; i < points.length; i += 1) {
        points[i].cluster = assignments[i];
      }

      return { changed, inertia, move: move / Math.max(1, k) };
    }

    function initializeAll() {
      buildGraph();
      randomQ();
      initKmeans();
      stepCount = 0;
      metrics = {
        shift: 0,
        changed: 0,
        inertia: 0,
        edgeCount
      };
      lastUpdate = null;
    }

    function regenerateData() {
      const s = sliders();
      const trueK = s.type === 'moons' ? 2 : s.trueK;
      points = generateData(s.type, s.count, s.sep, s.noise, trueK);
      initializeAll();
      updateLegend();
    }

    function runOneStep(source) {
      const s = sliders();

      const oldY = Y.map(r => r.slice());
      for (let t = 0; t < s.iter; t += 1) {
        const Z = matMulS(Q);
        orthonormalizeCols(Z);
        Q = Z;
      }
      Y = rowNormalize(Q);

      let shift = 0;
      for (let i = 0; i < Y.length; i += 1) {
        shift += Math.sqrt(distVec(Y[i], oldY[i]));
      }
      shift /= Math.max(1, Y.length);

      const km = kmeansStep();

      stepCount += 1;
      metrics = {
        shift,
        changed: km.changed,
        inertia: km.inertia,
        edgeCount
      };

      lastUpdate = {
        source,
        shift,
        changed: km.changed,
        inertia: km.inertia,
        centroidMove: km.move
      };

      if (km.changed === 0 && shift < 1e-4 && km.move < 1e-4 && stepCount > 4) {
        running = false;
      }
    }

    function drawMainPlot() {
      const w = plot.width;
      const h = plot.height;
      const pad = 56;
      const xMin = -4;
      const xMax = 4;
      const yMin = -4;
      const yMax = 4;
      const x2px = x => pad + ((x - xMin) * (w - 2 * pad)) / (xMax - xMin);
      const y2py = y => h - pad - ((y - yMin) * (h - 2 * pad)) / (yMax - yMin);

      pctx.clearRect(0, 0, w, h);
      pctx.fillStyle = 'rgba(7,14,30,0.55)';
      pctx.fillRect(pad, pad, w - 2 * pad, h - 2 * pad);

      pctx.strokeStyle = 'rgba(255,255,255,0.10)';
      pctx.lineWidth = 1;
      for (let i = 0; i <= 8; i += 1) {
        const x = xMin + (i * (xMax - xMin)) / 8;
        pctx.beginPath();
        pctx.moveTo(x2px(x), y2py(yMin));
        pctx.lineTo(x2px(x), y2py(yMax));
        pctx.stroke();
      }
      for (let i = 0; i <= 8; i += 1) {
        const y = yMin + (i * (yMax - yMin)) / 8;
        pctx.beginPath();
        pctx.moveTo(x2px(xMin), y2py(y));
        pctx.lineTo(x2px(xMax), y2py(y));
        pctx.stroke();
      }

      if (showGraph.checked) {
        pctx.strokeStyle = 'rgba(255,255,255,0.08)';
        pctx.lineWidth = 0.9;
        const drawMax = Math.min(edges.length, 900);
        for (let i = 0; i < drawMax; i += 1) {
          const e = edges[i];
          const a = points[e[0]];
          const b = points[e[1]];
          pctx.beginPath();
          pctx.moveTo(x2px(a.x), y2py(a.y));
          pctx.lineTo(x2px(b.x), y2py(b.y));
          pctx.stroke();
        }
      }

      for (const p of points) {
        pctx.fillStyle = colorOf(Math.max(0, p.cluster), 0.95);
        pctx.beginPath();
        pctx.arc(x2px(p.x), y2py(p.y), 4.1, 0, Math.PI * 2);
        pctx.fill();
      }

      pctx.fillStyle = 'rgba(232,238,255,0.88)';
      pctx.font = '12px "Hiragino Sans", sans-serif';
      pctx.fillText('スペクトル埋め込みで近くなる点が同色になります', x2px(-3.95), h - 20);
    }

    function drawEmbeddingPlot() {
      const w = embedPlot.width;
      const h = embedPlot.height;
      const pad = 38;

      ectx.clearRect(0, 0, w, h);
      ectx.fillStyle = 'rgba(7,14,30,0.55)';
      ectx.fillRect(pad, 14, w - 2 * pad, h - 24);

      if (Y.length === 0) return;

      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;

      for (let i = 0; i < Y.length; i += 1) {
        const vx = Y[i][0] || 0;
        const vy = Y[i][1] || 0;
        minX = Math.min(minX, vx);
        maxX = Math.max(maxX, vx);
        minY = Math.min(minY, vy);
        maxY = Math.max(maxY, vy);
      }

      if (maxX - minX < 1e-6) {
        maxX += 1;
        minX -= 1;
      }
      if (maxY - minY < 1e-6) {
        maxY += 1;
        minY -= 1;
      }

      const x2px = x => pad + ((x - minX) * (w - 2 * pad)) / (maxX - minX);
      const y2py = y => (h - 10) - ((y - minY) * (h - 28)) / (maxY - minY);

      ectx.strokeStyle = 'rgba(255,255,255,0.10)';
      ectx.lineWidth = 1;
      ectx.beginPath();
      ectx.moveTo(pad, y2py(0));
      ectx.lineTo(w - pad, y2py(0));
      ectx.stroke();
      ectx.beginPath();
      ectx.moveTo(x2px(0), 14);
      ectx.lineTo(x2px(0), h - 10);
      ectx.stroke();

      for (let i = 0; i < Y.length; i += 1) {
        const vx = Y[i][0] || 0;
        const vy = Y[i][1] || 0;
        ectx.fillStyle = colorOf(Math.max(0, assignments[i] || 0), 0.95);
        ectx.beginPath();
        ectx.arc(x2px(vx), y2py(vy), 3.8, 0, Math.PI * 2);
        ectx.fill();
      }

      for (let c = 0; c < centroids.length; c += 1) {
        const vx = centroids[c][0] || 0;
        const vy = centroids[c][1] || 0;
        ectx.strokeStyle = 'rgba(255,255,255,0.95)';
        ectx.lineWidth = 2;
        ectx.beginPath();
        ectx.moveTo(x2px(vx) - 5, y2py(vy) - 5);
        ectx.lineTo(x2px(vx) + 5, y2py(vy) + 5);
        ectx.stroke();
        ectx.beginPath();
        ectx.moveTo(x2px(vx) + 5, y2py(vy) - 5);
        ectx.lineTo(x2px(vx) - 5, y2py(vy) + 5);
        ectx.stroke();
      }

      ectx.fillStyle = 'rgba(230,237,255,0.88)';
      ectx.font = '11px "Hiragino Sans", sans-serif';
      ectx.fillText('Uの先頭2軸 (row-normalized)', pad + 8, 27);
      ectx.fillText(`shift=${metrics.shift.toFixed(5)} changed=${metrics.changed}`, pad + 8, h - 4);
    }

    function statusText() {
      if (stepCount < 2) {
        return { level: 'warn', text: '初期状態です。類似度グラフ上の固有空間を形成中です。' };
      }
      if (metrics.changed === 0 && metrics.shift < 1e-4) {
        return { level: 'good', text: '割当と埋め込みが安定し、収束に近づいています。' };
      }
      if (metrics.edgeCount < points.length * 0.9) {
        return { level: 'warn', text: 'グラフが疎です。k近傍やσを上げると連結性が上がります。' };
      }
      return { level: 'good', text: '埋め込み更新とK-means更新を反復中です。' };
    }

    function updateUI() {
      const s = sliders();
      const trueK = s.type === 'moons' ? 2 : s.trueK;

      document.getElementById('kVal').textContent = `${s.k}`;
      document.getElementById('knnVal').textContent = `${s.knn}`;
      document.getElementById('sigmaVal').textContent = s.sigma.toFixed(2);
      document.getElementById('iterVal').textContent = `${s.iter}`;
      document.getElementById('speedVal').textContent = `${s.speed}`;
      document.getElementById('countVal').textContent = `${s.count}`;
      document.getElementById('trueKVal').textContent = `${trueK}`;
      document.getElementById('sepVal').textContent = s.sep.toFixed(1);
      document.getElementById('noiseVal').textContent = s.noise.toFixed(2);

      trueKRange.disabled = s.type === 'moons';
      const maxK = Math.max(2, Math.min(8, points.length - 1));
      kRange.max = `${maxK}`;
      if (parseInt(kRange.value, 10) > maxK) kRange.value = `${maxK}`;

      document.getElementById('modePill').textContent = running ? 'モード: 学習中' : 'モード: 停止中';
      document.getElementById('statePill').textContent = running ? '状態: 計算中' : '状態: 一時停止';

      document.getElementById('stepVal').textContent = `${stepCount}`;
      document.getElementById('edgeVal').textContent = `${metrics.edgeCount}`;
      document.getElementById('shiftVal').textContent = metrics.shift.toFixed(5);
      document.getElementById('changeVal').textContent = `${metrics.changed}`;
      document.getElementById('inertiaVal').textContent = metrics.inertia.toFixed(5);

      const st = statusText();
      const statusBox = document.getElementById('statusBox');
      statusBox.className = `status ${st.level}`;
      statusBox.textContent = `評価: ${st.text}`;

      const lines = [];
      lines.push(`dataset=${s.type}, K=${s.k}, knn=${s.knn}, sigma=${s.sigma.toFixed(3)}`);
      lines.push(`step=${stepCount}, edges=${metrics.edgeCount}, shift=${metrics.shift.toFixed(6)}`);
      lines.push(`changed=${metrics.changed}, inertia=${metrics.inertia.toFixed(6)}`);
      if (lastUpdate) {
        lines.push(`source=${lastUpdate.source}, centroidMove=${lastUpdate.centroidMove.toFixed(6)}`);
      }
      document.getElementById('detailBox').textContent = lines.join('\n');

      updateLegend();
    }

    function frame(now) {
      const dt = now - lastT;
      lastT = now;

      if (running) {
        accMs += dt;
        const stepMs = 1000 / Math.max(1, sliders().speed);
        let guard = 0;
        while (accMs >= stepMs && guard < 80) {
          runOneStep('auto');
          accMs -= stepMs;
          guard += 1;
        }
      } else {
        accMs = 0;
      }

      drawMainPlot();
      drawEmbeddingPlot();
      updateUI();
      requestAnimationFrame(frame);
    }

    document.getElementById('btnPlay').addEventListener('click', () => {
      running = true;
    });

    document.getElementById('btnPause').addEventListener('click', () => {
      running = false;
    });

    document.getElementById('btnStep').addEventListener('click', () => {
      running = false;
      runOneStep('manual');
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      running = false;
      randomQ();
      initKmeans();
      stepCount = 0;
      metrics.shift = 0;
      metrics.changed = 0;
      metrics.inertia = 0;
      lastUpdate = null;
    });

    document.getElementById('btnNew').addEventListener('click', () => {
      running = false;
      regenerateData();
    });

    datasetType.addEventListener('change', () => {
      running = false;
      regenerateData();
    });

    const graphChanges = [kRange, knnRange, sigmaRange];
    for (const r of graphChanges) {
      r.addEventListener('change', () => {
        running = false;
        initializeAll();
      });
    }

    const dataChanges = [countRange, trueKRange, sepRange, noiseRange];
    for (const r of dataChanges) {
      r.addEventListener('change', () => {
        running = false;
        regenerateData();
      });
    }

    const live = [kRange, knnRange, sigmaRange, iterRange, speedRange, countRange, trueKRange, sepRange, noiseRange];
    for (const r of live) {
      r.addEventListener('input', updateUI);
    }
    showGraph.addEventListener('input', updateUI);

    regenerateData();
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
