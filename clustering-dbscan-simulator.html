<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DBSCAN クラスタリングシミュレータ</title>
  <style>
    :root {
      --bg:#081326;
      --panel:#0f1f3e;
      --text:#e9efff;
      --muted:#aab8de;
      --line:#2b406e;
      --warn:#ffd06b;
      --good:#67d79a;
      --bad:#ff8787;
      --accent:#73a7ff;
    }

    * { box-sizing:border-box; }

    body {
      margin:0;
      min-height:100vh;
      color:var(--text);
      font-family:"Hiragino Sans", "Noto Sans JP", "Yu Gothic", sans-serif;
      background:
        radial-gradient(circle at 12% 14%, rgba(115,167,255,0.17), transparent 34%),
        radial-gradient(circle at 88% 10%, rgba(111,223,167,0.16), transparent 28%),
        linear-gradient(180deg, #060f1d, var(--bg));
    }

    .top-nav {
      max-width:1220px;
      margin:14px auto 0;
      padding:0 18px;
      display:flex;
      gap:14px;
      flex-wrap:wrap;
    }

    .top-link {
      color:var(--muted);
      text-decoration:none;
      font-size:13px;
    }

    .top-link:hover {
      color:var(--text);
      text-decoration:underline;
    }

    .wrap {
      max-width:1220px;
      margin:0 auto;
      padding:16px 18px 24px;
      display:grid;
      grid-template-columns:1.22fr 0.78fr;
      gap:16px;
    }

    .card {
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.09);
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding:14px;
      box-shadow:0 15px 32px rgba(0,0,0,0.35);
    }

    h1 {
      margin:0 0 8px;
      font-size:19px;
      line-height:1.35;
    }

    .sub {
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.65;
    }

    .pill {
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.13);
      background:rgba(255,255,255,0.05);
      color:var(--muted);
      font-size:12px;
    }

    .formula {
      margin-top:10px;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(8,16,32,0.52);
      padding:9px;
      color:#dce5ff;
      font-size:12px;
      line-height:1.6;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }

    .desc {
      margin-top:10px;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(255,255,255,0.03);
      padding:9px;
      font-size:12px;
      line-height:1.6;
      color:#d4deff;
    }

    canvas {
      width:100%;
      height:auto;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(4,10,24,0.45);
    }

    .legend {
      margin-top:9px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      font-size:12px;
      color:var(--muted);
    }

    .dot {
      display:inline-block;
      width:10px;
      height:10px;
      border-radius:50%;
      margin-right:6px;
      vertical-align:middle;
    }

    .row {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    button {
      cursor:pointer;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      font-size:13px;
      padding:8px 10px;
      transition:background .2s ease;
    }

    button:hover { background:rgba(255,255,255,0.11); }

    button.primary {
      border-color:rgba(115,167,255,0.58);
      background:rgba(115,167,255,0.21);
    }

    button.primary:hover { background:rgba(115,167,255,0.28); }

    .selectrow {
      display:grid;
      grid-template-columns:120px 1fr;
      gap:10px;
      margin:8px 0;
      align-items:center;
      font-size:13px;
    }

    select {
      width:100%;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      padding:7px 8px;
      font-size:13px;
    }

    .slider {
      margin:10px 0;
      display:grid;
      grid-template-columns:140px 1fr 84px;
      gap:10px;
      align-items:center;
      font-size:13px;
    }

    input[type="range"] { width:100%; accent-color:#75a8ff; }

    .checkrow {
      margin:8px 0;
      color:var(--muted);
      font-size:13px;
      display:flex;
      align-items:center;
      gap:8px;
    }

    .hr {
      height:1px;
      margin:12px 0;
      background:rgba(255,255,255,0.11);
    }

    .kv {
      display:grid;
      grid-template-columns:1fr auto;
      gap:8px 10px;
      font-size:13px;
    }

    .kv div:nth-child(odd) { color:var(--muted); }

    .status {
      margin-top:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(0,0,0,0.2);
      padding:10px;
      font-size:13px;
      line-height:1.55;
    }

    .status.good {
      border-color:rgba(103,215,154,0.52);
      background:rgba(103,215,154,0.12);
    }

    .status.warn {
      border-color:rgba(255,208,107,0.52);
      background:rgba(255,208,107,0.12);
    }

    .detail {
      margin-top:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(2,8,20,0.55);
      padding:8px;
      color:#d8e2ff;
      font-size:12px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      max-height:170px;
      overflow:auto;
    }

    @media (max-width: 990px) {
      .wrap { grid-template-columns:1fr; }
      .slider { grid-template-columns:112px 1fr 84px; }
      .selectrow { grid-template-columns:100px 1fr; }
    }
  </style>
</head>
<body>
  <div class="top-nav">
    <a class="top-link" href="clustering-hub.html">← クラスタリングハブへ戻る</a>
    <a class="top-link" href="index.html">研修トップへ戻る</a>
  </div>

  <div class="wrap">
    <section class="card">
      <h1>DBSCAN クラスタリングシミュレータ</h1>
      <p class="sub">
        DBSCANは「距離ε以内に十分な点がある場所」をクラスタの核（core）として、
        密度連結でクラスタを広げる手法です。外れ値はノイズとして残せます。
      </p>

      <div class="formula">近傍定義
N_ε(p) = { q | dist(p,q) ≤ ε }

コア点条件
core(p) ⇔ |N_ε(p)| ≥ MinPts

クラスタ
cluster = density-reachable な点集合
(noise はどのクラスタにも属さない点)</div>

      <div class="desc">
        <b>パラメータ説明</b><br>
        `ε` は近傍半径、`MinPts` はコア判定に必要な最小点数です。
        `ε` が小さすぎるとノイズが増え、大きすぎるとクラスタが融合しやすくなります。
        `ノイズσ` を上げると密度差が弱まり、境界が曖昧になります。
      </div>

      <canvas id="plot" width="860" height="520"></canvas>

      <div class="legend" id="legend"></div>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <div style="font-size:14px; font-weight:700;">操作パネル</div>
        <div class="pill" id="modePill">モード: 実行中</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="primary" id="btnPlay">再生</button>
        <button id="btnPause">停止</button>
        <button id="btnStep">1ステップ</button>
        <button id="btnReset">探索リセット</button>
        <button id="btnNew">データ再生成</button>
      </div>

      <div class="hr"></div>

      <div class="selectrow">
        <div>データ形状</div>
        <select id="datasetType">
          <option value="blobs">ガウス塊</option>
          <option value="rings">同心円</option>
          <option value="moons">2つの月</option>
        </select>
      </div>

      <div class="slider">
        <div>ε (eps)</div>
        <input id="epsRange" type="range" min="0.08" max="2.20" step="0.01" value="0.48" />
        <div id="epsVal">0.48</div>
      </div>

      <div class="slider">
        <div>MinPts</div>
        <input id="minPtsRange" type="range" min="2" max="20" step="1" value="6" />
        <div id="minPtsVal">6</div>
      </div>

      <div class="slider">
        <div>更新/秒</div>
        <input id="speedRange" type="range" min="1" max="40" step="1" value="8" />
        <div id="speedVal">8</div>
      </div>

      <div class="slider">
        <div>点の数</div>
        <input id="countRange" type="range" min="30" max="280" step="2" value="140" />
        <div id="countVal">140</div>
      </div>

      <div class="slider">
        <div>生成クラスタ数</div>
        <input id="trueKRange" type="range" min="2" max="8" step="1" value="3" />
        <div id="trueKVal">3</div>
      </div>

      <div class="slider">
        <div>クラス間隔</div>
        <input id="sepRange" type="range" min="0.6" max="3.8" step="0.1" value="2.2" />
        <div id="sepVal">2.2</div>
      </div>

      <div class="slider">
        <div>ノイズ σ</div>
        <input id="noiseRange" type="range" min="0.03" max="1.20" step="0.01" value="0.32" />
        <div id="noiseVal">0.32</div>
      </div>

      <label class="checkrow"><input id="showEps" type="checkbox" checked /> 現在処理点の ε 近傍を表示</label>

      <div class="hr"></div>

      <div class="kv">
        <div>ステップ</div><div id="stepVal">0</div>
        <div>訪問済み / 全点</div><div id="visitVal">0 / 0</div>
        <div>検出クラスタ数</div><div id="clusterVal">0</div>
        <div>コア点数</div><div id="coreVal">0</div>
        <div>境界点数</div><div id="borderVal">0</div>
        <div>ノイズ点数</div><div id="noiseCntVal">0</div>
        <div>拡張キュー長</div><div id="queueVal">0</div>
      </div>

      <div id="statusBox" class="status">評価: 初期化中...</div>
      <div class="detail" id="detailBox">-</div>
    </section>
  </div>

  <script>
  (() => {
    function randn() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function clamp(v, lo, hi) {
      return Math.min(hi, Math.max(lo, v));
    }

    function sqDist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return dx * dx + dy * dy;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        const t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
      }
      return arr;
    }

    const palette = [
      [115, 167, 255],
      [255, 125, 125],
      [126, 226, 168],
      [255, 211, 109],
      [213, 155, 255],
      [135, 220, 255],
      [255, 168, 107],
      [145, 161, 255]
    ];

    function colorOf(id, alpha) {
      const c = palette[id % palette.length];
      return `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;
    }

    function generateData(type, count, sep, noise, trueK) {
      const points = [];
      for (let i = 0; i < count; i += 1) {
        const group = i % trueK;
        let x;
        let y;

        if (type === 'blobs') {
          const r = sep * 1.15 + 0.5;
          const a = (Math.PI * 2 * group) / trueK;
          x = r * Math.cos(a) + randn() * noise;
          y = 0.8 * r * Math.sin(a) + randn() * noise;
        } else if (type === 'rings') {
          const minR = 0.7;
          const ringGap = 0.55 + sep * 0.24;
          const radius = minR + group * ringGap;
          const t = Math.random() * Math.PI * 2;
          x = radius * Math.cos(t) + randn() * noise;
          y = radius * Math.sin(t) + randn() * noise;
        } else {
          const label = i < count / 2 ? 0 : 1;
          const t = Math.random() * Math.PI;
          if (label === 0) {
            x = Math.cos(t);
            y = Math.sin(t);
          } else {
            x = 1 - Math.cos(t);
            y = -Math.sin(t) - 0.5;
          }
          const sc = 2.0 + sep * 0.34;
          x = (x - 0.55) * sc + (label === 0 ? -sep * 0.2 : sep * 0.2);
          y = (y - 0.08) * sc;
          x += randn() * noise;
          y += randn() * noise;
        }

        points.push({
          x: clamp(x, -4, 4),
          y: clamp(y, -4, 4),
          group,
          label: -1,
          visited: false,
          queued: false,
          isCore: false
        });
      }
      return points;
    }

    const plot = document.getElementById('plot');
    const pctx = plot.getContext('2d');

    const datasetType = document.getElementById('datasetType');
    const epsRange = document.getElementById('epsRange');
    const minPtsRange = document.getElementById('minPtsRange');
    const speedRange = document.getElementById('speedRange');
    const countRange = document.getElementById('countRange');
    const trueKRange = document.getElementById('trueKRange');
    const sepRange = document.getElementById('sepRange');
    const noiseRange = document.getElementById('noiseRange');
    const showEps = document.getElementById('showEps');

    let points = [];
    let running = true;
    let finished = false;
    let stepCount = 0;

    let clusterCount = 0;
    let activeCluster = -1;
    let order = [];
    let scanCursor = 0;
    let expandQueue = [];

    let lastAction = null;

    let metrics = {
      visited: 0,
      core: 0,
      border: 0,
      noise: 0,
      clusters: 0,
      queue: 0
    };

    let lastT = performance.now();
    let accMs = 0;

    function sliders() {
      return {
        type: datasetType.value,
        eps: parseFloat(epsRange.value),
        minPts: parseInt(minPtsRange.value, 10),
        speed: parseInt(speedRange.value, 10),
        count: parseInt(countRange.value, 10),
        trueK: parseInt(trueKRange.value, 10),
        sep: parseFloat(sepRange.value),
        noise: parseFloat(noiseRange.value)
      };
    }

    function regionQuery(index, eps) {
      const p = points[index];
      const r2 = eps * eps;
      const neighbors = [];
      for (let i = 0; i < points.length; i += 1) {
        if (sqDist(p, points[i]) <= r2) neighbors.push(i);
      }
      return neighbors;
    }

    function recomputeMetrics() {
      let visited = 0;
      let core = 0;
      let border = 0;
      let noise = 0;
      let maxLabel = -1;

      for (const p of points) {
        if (p.visited) visited += 1;
        if (p.label >= 0) {
          maxLabel = Math.max(maxLabel, p.label);
          if (p.isCore) core += 1;
          else border += 1;
        } else if (p.visited) {
          noise += 1;
        }
      }

      metrics = {
        visited,
        core,
        border,
        noise,
        clusters: maxLabel + 1,
        queue: expandQueue.length
      };
    }

    function resetAlgorithm() {
      for (const p of points) {
        p.label = -1;
        p.visited = false;
        p.queued = false;
        p.isCore = false;
      }

      order = shuffle(new Array(points.length).fill(0).map((_, i) => i));
      scanCursor = 0;
      expandQueue = [];
      clusterCount = 0;
      activeCluster = -1;
      stepCount = 0;
      finished = false;
      lastAction = {
        phase: 'init',
        text: '探索順序を初期化しました。',
        point: -1,
        neighbors: 0,
        cluster: -1,
        source: 'init'
      };
      recomputeMetrics();
    }

    function regenerateData() {
      const s = sliders();
      const trueK = s.type === 'moons' ? 2 : s.trueK;
      points = generateData(s.type, s.count, s.sep, s.noise, trueK);
      resetAlgorithm();
      updateLegend();
    }

    function findNextUnvisited() {
      while (scanCursor < order.length) {
        const idx = order[scanCursor];
        scanCursor += 1;
        if (!points[idx].visited) return idx;
      }
      return -1;
    }

    function runOneStep(source) {
      if (finished) return;

      const s = sliders();
      stepCount += 1;

      if (expandQueue.length > 0) {
        const idx = expandQueue.shift();
        points[idx].queued = false;
        const p = points[idx];

        if (!p.visited) p.visited = true;

        const neighbors = regionQuery(idx, s.eps);
        const isCore = neighbors.length >= s.minPts;
        if (isCore) {
          p.isCore = true;
          for (const ni of neighbors) {
            const q = points[ni];
            if (q.label < 0) q.label = activeCluster;
            if (!q.visited && !q.queued) {
              q.queued = true;
              expandQueue.push(ni);
            }
          }
        }

        if (p.label < 0) p.label = activeCluster;

        lastAction = {
          phase: 'expand',
          text: isCore
            ? `クラスタ ${activeCluster} を拡張。core点のため近傍をキューへ追加しました。`
            : `点 ${idx} は境界点として処理しました。`,
          point: idx,
          neighbors: neighbors.length,
          cluster: activeCluster,
          source
        };
      } else {
        const idx = findNextUnvisited();

        if (idx < 0) {
          finished = true;
          lastAction = {
            phase: 'done',
            text: '全点の探索が完了しました。',
            point: -1,
            neighbors: 0,
            cluster: -1,
            source
          };
          recomputeMetrics();
          return;
        }

        const p = points[idx];
        p.visited = true;
        const neighbors = regionQuery(idx, s.eps);

        if (neighbors.length < s.minPts) {
          p.label = -1;
          p.isCore = false;
          lastAction = {
            phase: 'scan-noise',
            text: `点 ${idx} は |Nε|=${neighbors.length} で MinPts=${s.minPts} 未満のためノイズ候補です。`,
            point: idx,
            neighbors: neighbors.length,
            cluster: -1,
            source
          };
        } else {
          const cid = clusterCount;
          clusterCount += 1;
          activeCluster = cid;

          p.label = cid;
          p.isCore = true;

          for (const ni of neighbors) {
            if (ni === idx) continue;
            const q = points[ni];
            if (q.label < 0) q.label = cid;
            if (!q.visited && !q.queued) {
              q.queued = true;
              expandQueue.push(ni);
            }
          }

          lastAction = {
            phase: 'scan-core',
            text: `新クラスタ ${cid} を開始。core点から密度連結探索へ進みます。`,
            point: idx,
            neighbors: neighbors.length,
            cluster: cid,
            source
          };
        }
      }

      if (scanCursor >= order.length && expandQueue.length === 0) {
        let allVisited = true;
        for (const p of points) {
          if (!p.visited) {
            allVisited = false;
            break;
          }
        }
        if (allVisited) finished = true;
      }

      recomputeMetrics();
    }

    function updateLegend() {
      const chunks = [];
      const showClusters = Math.min(8, Math.max(1, metrics.clusters));
      for (let i = 0; i < showClusters; i += 1) {
        chunks.push(`<span><span class="dot" style="background:${colorOf(i, 0.95)}"></span>cluster ${i}</span>`);
      }
      chunks.push('<span><span class="dot" style="background:rgba(255,208,107,0.95)"></span>noise</span>');
      chunks.push('<span><span class="dot" style="background:#ffffff"></span>core点リング</span>');
      chunks.push('<span><span class="dot" style="background:rgba(115,167,255,0.6)"></span>現在点のε円</span>');
      document.getElementById('legend').innerHTML = chunks.join('');
    }

    function statusText() {
      if (finished) {
        return {
          level: 'good',
          text: `探索完了。クラスタ ${metrics.clusters} 個、ノイズ ${metrics.noise} 点です。`
        };
      }
      if (expandQueue.length > 0) {
        return {
          level: 'good',
          text: 'コア点の近傍をたどってクラスタ拡張中です。'
        };
      }
      return {
        level: 'warn',
        text: '次の未訪問点を調べて新クラスタを開始するか判定中です。'
      };
    }

    function drawPlot() {
      const w = plot.width;
      const h = plot.height;
      const pad = 56;
      const xMin = -4;
      const xMax = 4;
      const yMin = -4;
      const yMax = 4;
      const x2px = x => pad + ((x - xMin) * (w - 2 * pad)) / (xMax - xMin);
      const y2py = y => h - pad - ((y - yMin) * (h - 2 * pad)) / (yMax - yMin);

      pctx.clearRect(0, 0, w, h);
      pctx.fillStyle = 'rgba(7,14,30,0.55)';
      pctx.fillRect(pad, pad, w - 2 * pad, h - 2 * pad);

      pctx.strokeStyle = 'rgba(255,255,255,0.10)';
      pctx.lineWidth = 1;
      for (let i = 0; i <= 8; i += 1) {
        const x = xMin + (i * (xMax - xMin)) / 8;
        pctx.beginPath();
        pctx.moveTo(x2px(x), y2py(yMin));
        pctx.lineTo(x2px(x), y2py(yMax));
        pctx.stroke();
      }
      for (let i = 0; i <= 8; i += 1) {
        const y = yMin + (i * (yMax - yMin)) / 8;
        pctx.beginPath();
        pctx.moveTo(x2px(xMin), y2py(y));
        pctx.lineTo(x2px(xMax), y2py(y));
        pctx.stroke();
      }

      if (showEps.checked && lastAction && lastAction.point >= 0) {
        const p = points[lastAction.point];
        const radiusPx = ((sliders().eps) * (w - 2 * pad)) / (xMax - xMin);
        pctx.strokeStyle = 'rgba(115,167,255,0.6)';
        pctx.lineWidth = 1.6;
        pctx.beginPath();
        pctx.arc(x2px(p.x), y2py(p.y), radiusPx, 0, Math.PI * 2);
        pctx.stroke();
      }

      for (let i = 0; i < points.length; i += 1) {
        const p = points[i];
        const px = x2px(p.x);
        const py = y2py(p.y);

        if (p.label >= 0) pctx.fillStyle = colorOf(p.label, 0.95);
        else if (p.visited) pctx.fillStyle = 'rgba(255,208,107,0.95)';
        else pctx.fillStyle = 'rgba(170,184,222,0.55)';

        pctx.beginPath();
        pctx.arc(px, py, p.queued ? 4.9 : 4.1, 0, Math.PI * 2);
        pctx.fill();

        if (p.isCore) {
          pctx.strokeStyle = 'rgba(255,255,255,0.92)';
          pctx.lineWidth = 1.2;
          pctx.beginPath();
          pctx.arc(px, py, 7.2, 0, Math.PI * 2);
          pctx.stroke();
        }
      }

      if (lastAction && lastAction.point >= 0) {
        const p = points[lastAction.point];
        pctx.strokeStyle = 'rgba(255,255,255,0.95)';
        pctx.lineWidth = 2;
        pctx.beginPath();
        pctx.arc(x2px(p.x), y2py(p.y), 9.2, 0, Math.PI * 2);
        pctx.stroke();
      }

      pctx.fillStyle = 'rgba(232,238,255,0.88)';
      pctx.font = '12px "Hiragino Sans", sans-serif';
      pctx.fillText('灰色: 未訪問 / 黄: ノイズ候補 / 色付き: クラスタ所属', x2px(-3.95), h - 20);
    }

    function updateUI() {
      const s = sliders();
      const trueK = s.type === 'moons' ? 2 : s.trueK;

      document.getElementById('epsVal').textContent = s.eps.toFixed(2);
      document.getElementById('minPtsVal').textContent = `${s.minPts}`;
      document.getElementById('speedVal').textContent = `${s.speed}`;
      document.getElementById('countVal').textContent = `${s.count}`;
      document.getElementById('trueKVal').textContent = `${trueK}`;
      document.getElementById('sepVal').textContent = s.sep.toFixed(1);
      document.getElementById('noiseVal').textContent = s.noise.toFixed(2);

      trueKRange.disabled = s.type === 'moons';

      document.getElementById('modePill').textContent = running ? 'モード: 実行中' : 'モード: 停止中';

      document.getElementById('stepVal').textContent = `${stepCount}`;
      document.getElementById('visitVal').textContent = `${metrics.visited} / ${points.length}`;
      document.getElementById('clusterVal').textContent = `${metrics.clusters}`;
      document.getElementById('coreVal').textContent = `${metrics.core}`;
      document.getElementById('borderVal').textContent = `${metrics.border}`;
      document.getElementById('noiseCntVal').textContent = `${metrics.noise}`;
      document.getElementById('queueVal').textContent = `${metrics.queue}`;

      const st = statusText();
      const statusBox = document.getElementById('statusBox');
      statusBox.className = `status ${st.level}`;
      statusBox.textContent = `評価: ${st.text}`;

      const details = [];
      details.push(`dataset=${s.type}, eps=${s.eps.toFixed(3)}, minPts=${s.minPts}`);
      details.push(`step=${stepCount}, visited=${metrics.visited}/${points.length}, queue=${expandQueue.length}`);
      details.push(`clusters=${metrics.clusters}, core=${metrics.core}, border=${metrics.border}, noise=${metrics.noise}`);
      if (lastAction) {
        details.push(`phase=${lastAction.phase}, source=${lastAction.source}`);
        details.push(`point=${lastAction.point}, |Neps|=${lastAction.neighbors}, cluster=${lastAction.cluster}`);
        details.push(lastAction.text);
      }
      document.getElementById('detailBox').textContent = details.join('\n');

      updateLegend();
    }

    function frame(now) {
      const dt = now - lastT;
      lastT = now;

      if (running) {
        accMs += dt;
        const stepMs = 1000 / Math.max(1, sliders().speed);
        let guard = 0;
        while (accMs >= stepMs && guard < 120) {
          runOneStep('auto');
          accMs -= stepMs;
          guard += 1;
        }
      } else {
        accMs = 0;
      }

      drawPlot();
      updateUI();
      requestAnimationFrame(frame);
    }

    document.getElementById('btnPlay').addEventListener('click', () => {
      running = true;
    });

    document.getElementById('btnPause').addEventListener('click', () => {
      running = false;
    });

    document.getElementById('btnStep').addEventListener('click', () => {
      running = false;
      runOneStep('manual');
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      running = false;
      resetAlgorithm();
    });

    document.getElementById('btnNew').addEventListener('click', () => {
      running = false;
      regenerateData();
    });

    datasetType.addEventListener('change', () => {
      running = false;
      regenerateData();
    });

    countRange.addEventListener('change', () => {
      running = false;
      regenerateData();
    });

    trueKRange.addEventListener('change', () => {
      running = false;
      regenerateData();
    });

    sepRange.addEventListener('change', () => {
      running = false;
      regenerateData();
    });

    noiseRange.addEventListener('change', () => {
      running = false;
      regenerateData();
    });

    epsRange.addEventListener('change', () => {
      running = false;
      resetAlgorithm();
    });

    minPtsRange.addEventListener('change', () => {
      running = false;
      resetAlgorithm();
    });

    const live = [epsRange, minPtsRange, speedRange, countRange, trueKRange, sepRange, noiseRange];
    for (const r of live) {
      r.addEventListener('input', updateUI);
    }
    showEps.addEventListener('input', updateUI);

    regenerateData();
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
