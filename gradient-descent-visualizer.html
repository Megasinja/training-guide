<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>勾配降下法ビジュアライザ</title>
  <style>
    :root {
      --bg:#081326;
      --panel:#0f1f3e;
      --text:#e9efff;
      --muted:#aab8de;
      --line:#2b406e;
      --path:#ffe178;
      --point:#ff8e8e;
      --good:#6fdfa7;
      --bad:#ff8b8b;
      --grad:#ff94bd;
      --upd:#7fd6ff;
      --loss:#ffd974;
      --gnorm:#9fc8ff;
    }

    * { box-sizing:border-box; }

    body {
      margin:0;
      min-height:100vh;
      color:var(--text);
      font-family:"Hiragino Sans", "Noto Sans JP", "Yu Gothic", sans-serif;
      background:
        radial-gradient(circle at 10% 15%, rgba(115,167,255,0.18), transparent 34%),
        radial-gradient(circle at 90% 10%, rgba(111,223,167,0.15), transparent 28%),
        linear-gradient(180deg, #060f1d, var(--bg));
    }

    .top-nav {
      max-width:1200px;
      margin:14px auto 0;
      padding:0 18px;
    }

    .top-link {
      color:var(--muted);
      text-decoration:none;
      font-size:13px;
    }

    .top-link:hover {
      color:var(--text);
      text-decoration:underline;
    }

    .wrap {
      max-width:1200px;
      margin:0 auto;
      padding:16px 18px 24px;
      display:grid;
      grid-template-columns:1.24fr 0.76fr;
      gap:16px;
    }

    .card {
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.09);
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding:14px;
      box-shadow:0 15px 32px rgba(0,0,0,0.35);
    }

    h1 {
      margin:0 0 8px;
      font-size:19px;
      line-height:1.35;
    }

    .sub {
      margin:0 0 12px;
      color:var(--muted);
      font-size:13px;
      line-height:1.65;
    }

    .pill {
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.13);
      background:rgba(255,255,255,0.05);
      color:var(--muted);
      font-size:12px;
    }

    canvas {
      width:100%;
      height:auto;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(4,10,24,0.45);
    }

    .legend {
      margin-top:9px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      font-size:12px;
      color:var(--muted);
    }

    .dot {
      display:inline-block;
      width:10px;
      height:10px;
      border-radius:50%;
      margin-right:6px;
      vertical-align:middle;
    }

    .mini-title {
      margin:12px 0 7px;
      font-size:13px;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .row {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
    }

    button {
      cursor:pointer;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      font-size:13px;
      padding:8px 10px;
      transition:background .2s ease;
    }

    button:hover {
      background:rgba(255,255,255,0.11);
    }

    button.primary {
      border-color:rgba(115,167,255,0.58);
      background:rgba(115,167,255,0.21);
    }

    button.primary:hover {
      background:rgba(115,167,255,0.28);
    }

    .selectrow {
      display:grid;
      grid-template-columns:120px 1fr;
      gap:10px;
      margin:8px 0;
      align-items:center;
      font-size:13px;
    }

    select {
      width:100%;
      border-radius:9px;
      border:1px solid rgba(255,255,255,0.15);
      background:rgba(255,255,255,0.06);
      color:var(--text);
      padding:7px 8px;
      font-size:13px;
    }

    .slider {
      margin:10px 0;
      display:grid;
      grid-template-columns:136px 1fr 88px;
      gap:10px;
      align-items:center;
      font-size:13px;
    }

    input[type="range"] {
      width:100%;
      accent-color:#75a8ff;
    }

    .hr {
      height:1px;
      margin:12px 0;
      background:rgba(255,255,255,0.11);
    }

    .kv {
      display:grid;
      grid-template-columns:1fr auto;
      gap:8px 10px;
      font-size:13px;
    }

    .kv div:nth-child(odd) {
      color:var(--muted);
    }

    .status {
      margin-top:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.1);
      background:rgba(0,0,0,0.2);
      padding:10px;
      font-size:13px;
      line-height:1.55;
    }

    .status.good {
      border-color:rgba(103,215,154,0.52);
      background:rgba(103,215,154,0.12);
    }

    .status.warn {
      border-color:rgba(255,208,107,0.52);
      background:rgba(255,208,107,0.12);
    }

    .status.bad {
      border-color:rgba(255,135,135,0.55);
      background:rgba(255,135,135,0.12);
    }

    .detail {
      margin-top:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.09);
      background:rgba(2,8,20,0.55);
      padding:8px;
      color:#d8e2ff;
      font-size:12px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre;
      max-height:180px;
      overflow:auto;
    }

    .formula {
      margin-top:8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.08);
      background:rgba(8,16,32,0.55);
      padding:8px;
      color:#dce5ff;
      font-size:12px;
      line-height:1.55;
    }

    .note {
      margin:10px 0 0;
      color:var(--muted);
      font-size:12px;
      line-height:1.6;
    }

    @media (max-width: 990px) {
      .wrap { grid-template-columns:1fr; }
      .slider { grid-template-columns:112px 1fr 88px; }
      .selectrow { grid-template-columns:100px 1fr; }
    }
  </style>
</head>
<body>
  <div class="top-nav">
    <a class="top-link" href="index.html">← 新卒AI研修トップへ戻る</a>
  </div>

  <div class="wrap">
    <section class="card">
      <h1>勾配降下法ビジュアライザ</h1>
      <p class="sub">
        2変数関数の地形（等高線）上で、
        <span class="pill">現在点</span> がどう移動するかを可視化します。
        <span class="pill">SGD / Momentum / Adam</span> を切り替え、
        学習率や減衰、勾配クリップで挙動の違いを比較できます。3Dビューでは点が高さ方向も含めて移動します。
      </p>

      <canvas id="plot" width="860" height="520"></canvas>

      <div class="legend">
        <span><span class="dot" style="background:var(--path)"></span>探索軌跡</span>
        <span><span class="dot" style="background:var(--point)"></span>現在位置</span>
        <span><span class="dot" style="background:var(--grad)"></span>勾配ベクトル ∇f</span>
        <span><span class="dot" style="background:var(--upd)"></span>更新ベクトル Δθ</span>
        <span><span class="dot" style="background:var(--good)"></span>既知の最小点（参考）</span>
      </div>

      <div class="mini-title">
        <span>3D地形ビュー（点が3次元上を移動）</span>
      </div>
      <canvas id="surfacePlot" width="860" height="420"></canvas>

      <div class="mini-title">
        <span>Loss と ||∇f|| の推移</span>
        <span class="pill" id="modePill">モード: 学習中</span>
      </div>
      <canvas id="lossPlot" width="860" height="190"></canvas>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;">
        <div style="font-size:14px; font-weight:700;">操作パネル</div>
        <div class="pill" id="statePill">状態: 計算中</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="primary" id="btnPlay">再生</button>
        <button id="btnPause">停止</button>
        <button id="btnStep">1ステップ</button>
        <button id="btnReset">開始点へリセット</button>
        <button id="btnRandom">開始点ランダム</button>
      </div>

      <div class="hr"></div>

      <div class="selectrow">
        <div>目的関数</div>
        <select id="fnSelect">
          <option value="quadratic">二次関数（凸）</option>
          <option value="rosenbrock">Rosenbrock（細い谷）</option>
          <option value="himmelblau">Himmelblau（多峰性）</option>
          <option value="rastrigin">Rastrigin（局所解多い）</option>
        </select>
      </div>

      <div class="selectrow">
        <div>最適化手法</div>
        <select id="optSelect">
          <option value="sgd">SGD</option>
          <option value="momentum">Momentum</option>
          <option value="adam">Adam</option>
        </select>
      </div>

      <div class="slider">
        <div>学習率 η</div>
        <input id="lrRange" type="range" min="0.0005" max="0.3000" step="0.0005" value="0.0200" />
        <div id="lrVal">0.0200</div>
      </div>

      <div class="slider">
        <div>減衰 ρ</div>
        <input id="decayRange" type="range" min="0.000" max="0.050" step="0.001" value="0.004" />
        <div id="decayVal">0.004</div>
      </div>

      <div class="slider">
        <div>β1</div>
        <input id="beta1Range" type="range" min="0.00" max="0.99" step="0.01" value="0.90" />
        <div id="beta1Val">0.90</div>
      </div>

      <div class="slider">
        <div>β2</div>
        <input id="beta2Range" type="range" min="0.50" max="0.999" step="0.001" value="0.999" />
        <div id="beta2Val">0.999</div>
      </div>

      <div class="slider">
        <div>勾配クリップ</div>
        <input id="clipRange" type="range" min="0.00" max="50.00" step="0.10" value="8.00" />
        <div id="clipVal">8.00</div>
      </div>

      <div class="slider">
        <div>勾配ノイズ σ</div>
        <input id="noiseRange" type="range" min="0.00" max="2.00" step="0.01" value="0.00" />
        <div id="noiseVal">0.00</div>
      </div>

      <div class="slider">
        <div>更新/秒</div>
        <input id="speedRange" type="range" min="1" max="220" step="1" value="30" />
        <div id="speedVal">30</div>
      </div>

      <div class="slider">
        <div>視点 方位角</div>
        <input id="azRange" type="range" min="-180" max="180" step="1" value="35" />
        <div id="azVal">35°</div>
      </div>

      <div class="slider">
        <div>視点 仰角</div>
        <input id="elRange" type="range" min="10" max="80" step="1" value="32" />
        <div id="elVal">32°</div>
      </div>

      <div class="slider">
        <div>高さスケール</div>
        <input id="zScaleRange" type="range" min="0.40" max="2.00" step="0.01" value="1.00" />
        <div id="zScaleVal">1.00</div>
      </div>

      <div class="slider">
        <div>開始 x</div>
        <input id="startXRange" type="range" min="-4" max="4" step="0.01" value="-3.20" />
        <div id="startXVal">-3.20</div>
      </div>

      <div class="slider">
        <div>開始 y</div>
        <input id="startYRange" type="range" min="-4" max="4" step="0.01" value="3.10" />
        <div id="startYVal">3.10</div>
      </div>

      <div class="formula">
        更新式（基本）: <code>θ_{t+1} = θ_t - η_t ∇f(θ_t)</code><br>
        学習率: <code>η_t = η / (1 + ρt)</code>
      </div>

      <div class="hr"></div>

      <div class="kv">
        <div>ステップ</div><div id="stepVal">0</div>
        <div>現在 f(x,y)</div><div id="fNowVal">-</div>
        <div>現在 ||∇f||</div><div id="gNormVal">-</div>
        <div>現在座標 (x,y)</div><div id="xyNowVal">-</div>
        <div>ベスト f</div><div id="bestVal">-</div>
        <div>ベスト座標</div><div id="bestXYVal">-</div>
        <div>現在 η_t</div><div id="etaVal">-</div>
        <div>直前 Δf</div><div id="deltaFVal">-</div>
        <div>直前移動量 ||Δθ||</div><div id="moveVal">-</div>
      </div>

      <div id="statusBox" class="status">評価: 初期化中...</div>

      <div class="hr"></div>
      <div style="font-size:13px; color:var(--muted);">計算の詳細</div>
      <div class="detail" id="detailBox">-</div>

      <p class="note">
        学び方の例:
        <code>quadratic</code> で基本を確認 →
        <code>rosenbrock</code> で谷の難しさを体験 →
        <code>himmelblau / rastrigin</code> で初期値依存と局所解を観察。
      </p>
    </section>
  </div>

  <script>
  (() => {
    function randn() {
      let u = 0;
      let v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function clamp(v, lo, hi) {
      return Math.min(hi, Math.max(lo, v));
    }

    function hypot2(x, y) {
      return Math.sqrt(x * x + y * y);
    }

    function colorMix(a, b, t) {
      return [
        Math.round(a[0] + (b[0] - a[0]) * t),
        Math.round(a[1] + (b[1] - a[1]) * t),
        Math.round(a[2] + (b[2] - a[2]) * t)
      ];
    }

    function heatRgb(t) {
      const c1 = [18, 38, 82];
      const c2 = [46, 108, 204];
      const c3 = [108, 205, 166];
      const c4 = [249, 221, 117];
      const c5 = [234, 94, 109];

      const u = clamp(t, 0, 1);
      if (u < 0.25) {
        return colorMix(c1, c2, u / 0.25);
      }
      if (u < 0.5) {
        return colorMix(c2, c3, (u - 0.25) / 0.25);
      }
      if (u < 0.75) {
        return colorMix(c3, c4, (u - 0.5) / 0.25);
      }
      return colorMix(c4, c5, (u - 0.75) / 0.25);
    }

    function heatColor(t) {
      const c = heatRgb(t);
      return `rgb(${c[0]},${c[1]},${c[2]})`;
    }

    function heatColorA(t, alpha) {
      const c = heatRgb(t);
      return `rgba(${c[0]},${c[1]},${c[2]},${alpha})`;
    }

    function drawArrow(ctx, x0, y0, x1, y1, color, width) {
      const dx = x1 - x0;
      const dy = y1 - y0;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len < 1e-6) return;

      const ux = dx / len;
      const uy = dy / len;
      const head = Math.min(12, Math.max(7, len * 0.22));

      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x1 - ux * head - uy * head * 0.55, y1 - uy * head + ux * head * 0.55);
      ctx.lineTo(x1 - ux * head + uy * head * 0.55, y1 - uy * head - ux * head * 0.55);
      ctx.closePath();
      ctx.fill();
    }

    const functions = {
      quadratic: {
        label: '二次関数（凸）',
        equation: 'f(x,y) = (x-1)^2 + 2(y+0.5)^2',
        domain: { xmin: -4, xmax: 4, ymin: -4, ymax: 4 },
        start: { x: -3.2, y: 3.1 },
        optima: [{ x: 1.0, y: -0.5 }],
        fn: (x, y) => (x - 1) * (x - 1) + 2 * (y + 0.5) * (y + 0.5),
        grad: (x, y) => ({ gx: 2 * (x - 1), gy: 4 * (y + 0.5) })
      },
      rosenbrock: {
        label: 'Rosenbrock（細い谷）',
        equation: 'f(x,y) = (1-x)^2 + 100(y-x^2)^2',
        domain: { xmin: -2.2, xmax: 2.2, ymin: -1.2, ymax: 3.0 },
        start: { x: -1.4, y: 1.8 },
        optima: [{ x: 1.0, y: 1.0 }],
        fn: (x, y) => {
          const t1 = 1 - x;
          const t2 = y - x * x;
          return t1 * t1 + 100 * t2 * t2;
        },
        grad: (x, y) => {
          const t2 = y - x * x;
          return {
            gx: -2 * (1 - x) - 400 * x * t2,
            gy: 200 * t2
          };
        }
      },
      himmelblau: {
        label: 'Himmelblau（多峰性）',
        equation: 'f(x,y) = (x^2+y-11)^2 + (x+y^2-7)^2',
        domain: { xmin: -6, xmax: 6, ymin: -6, ymax: 6 },
        start: { x: -4.0, y: 0.0 },
        optima: [
          { x: 3.0, y: 2.0 },
          { x: -2.805118, y: 3.131312 },
          { x: -3.779310, y: -3.283186 },
          { x: 3.584428, y: -1.848126 }
        ],
        fn: (x, y) => {
          const a = x * x + y - 11;
          const b = x + y * y - 7;
          return a * a + b * b;
        },
        grad: (x, y) => {
          const a = x * x + y - 11;
          const b = x + y * y - 7;
          return {
            gx: 4 * x * a + 2 * b,
            gy: 2 * a + 4 * y * b
          };
        }
      },
      rastrigin: {
        label: 'Rastrigin（局所解多い）',
        equation: 'f(x,y) = 20 + x^2 + y^2 - 10(cos2πx + cos2πy)',
        domain: { xmin: -5.2, xmax: 5.2, ymin: -5.2, ymax: 5.2 },
        start: { x: 3.8, y: 3.6 },
        optima: [{ x: 0.0, y: 0.0 }],
        fn: (x, y) => 20 + x * x + y * y - 10 * (Math.cos(2 * Math.PI * x) + Math.cos(2 * Math.PI * y)),
        grad: (x, y) => ({
          gx: 2 * x + 20 * Math.PI * Math.sin(2 * Math.PI * x),
          gy: 2 * y + 20 * Math.PI * Math.sin(2 * Math.PI * y)
        })
      }
    };

    const plot = document.getElementById('plot');
    const pctx = plot.getContext('2d');
    const surfacePlot = document.getElementById('surfacePlot');
    const sctx = surfacePlot.getContext('2d');
    const lossPlot = document.getElementById('lossPlot');
    const lctx = lossPlot.getContext('2d');

    const fnSelect = document.getElementById('fnSelect');
    const optSelect = document.getElementById('optSelect');

    const lrRange = document.getElementById('lrRange');
    const decayRange = document.getElementById('decayRange');
    const beta1Range = document.getElementById('beta1Range');
    const beta2Range = document.getElementById('beta2Range');
    const clipRange = document.getElementById('clipRange');
    const noiseRange = document.getElementById('noiseRange');
    const speedRange = document.getElementById('speedRange');
    const azRange = document.getElementById('azRange');
    const elRange = document.getElementById('elRange');
    const zScaleRange = document.getElementById('zScaleRange');
    const startXRange = document.getElementById('startXRange');
    const startYRange = document.getElementById('startYRange');

    const sliders = [
      lrRange,
      decayRange,
      beta1Range,
      beta2Range,
      clipRange,
      noiseRange,
      speedRange,
      azRange,
      elRange,
      zScaleRange,
      startXRange,
      startYRange
    ];

    let running = true;
    let stepCount = 0;
    let x = 0;
    let y = 0;

    let velocity = { x: 0, y: 0 };
    let adam = { mx: 0, my: 0, vx: 0, vy: 0 };

    let best = { f: Infinity, x: 0, y: 0 };
    let trajectory = [];
    let lossHistory = [];
    let lastUpdate = null;

    let lastT = performance.now();
    let accMs = 0;

    let bgCanvas = null;
    let zStats = { lMin: 0, lMax: 1 };
    let surfaceMesh = null;
    const maxHistory = 360;
    const maxTrajectory = 1800;

    function currentFunction() {
      return functions[fnSelect.value];
    }

    function ui() {
      return {
        optimizer: optSelect.value,
        lr: parseFloat(lrRange.value),
        decay: parseFloat(decayRange.value),
        beta1: parseFloat(beta1Range.value),
        beta2: parseFloat(beta2Range.value),
        clip: parseFloat(clipRange.value),
        noise: parseFloat(noiseRange.value),
        speed: parseInt(speedRange.value, 10),
        azimuth: parseFloat(azRange.value) * Math.PI / 180,
        elevation: parseFloat(elRange.value) * Math.PI / 180,
        zScale: parseFloat(zScaleRange.value)
      };
    }

    function zToUnit(z) {
      const lv = Math.log1p(Math.max(0, z));
      return clamp((lv - zStats.lMin) / Math.max(1e-9, zStats.lMax - zStats.lMin), 0, 1);
    }

    function toWorld(xv, yv, zv, d, zScale) {
      const wx = ((xv - d.xmin) / Math.max(1e-9, d.xmax - d.xmin) - 0.5) * 2;
      const wy = ((yv - d.ymin) / Math.max(1e-9, d.ymax - d.ymin) - 0.5) * 2;
      const wz = (zToUnit(zv) - 0.5) * 2 * zScale;
      return { wx, wy, wz };
    }

    function project3D(wx, wy, wz, view) {
      const x1 = wx * Math.cos(view.azimuth) - wy * Math.sin(view.azimuth);
      const y1 = wx * Math.sin(view.azimuth) + wy * Math.cos(view.azimuth);
      const z1 = wz;

      const y2 = y1 * Math.cos(view.elevation) - z1 * Math.sin(view.elevation);
      const z2 = y1 * Math.sin(view.elevation) + z1 * Math.cos(view.elevation);

      const depth = y2 + 3.1;
      const k = 255 / Math.max(0.35, depth);
      return {
        sx: view.cx + x1 * k,
        sy: view.cy - z2 * k,
        depth
      };
    }

    function setStartSliderRange() {
      const d = currentFunction().domain;
      startXRange.min = d.xmin;
      startXRange.max = d.xmax;
      startYRange.min = d.ymin;
      startYRange.max = d.ymax;
    }

    function setStartSliders(x0, y0) {
      startXRange.value = clamp(x0, parseFloat(startXRange.min), parseFloat(startXRange.max));
      startYRange.value = clamp(y0, parseFloat(startYRange.min), parseFloat(startYRange.max));
    }

    function currentStart() {
      return {
        x: parseFloat(startXRange.value),
        y: parseFloat(startYRange.value)
      };
    }

    function resetOptimizerState() {
      velocity.x = 0;
      velocity.y = 0;
      adam.mx = 0;
      adam.my = 0;
      adam.vx = 0;
      adam.vy = 0;
    }

    function randomStartPoint() {
      const d = currentFunction().domain;
      const mx = (d.xmax - d.xmin) * 0.08;
      const my = (d.ymax - d.ymin) * 0.08;
      return {
        x: d.xmin + mx + Math.random() * (d.xmax - d.xmin - 2 * mx),
        y: d.ymin + my + Math.random() * (d.ymax - d.ymin - 2 * my)
      };
    }

    function softReset(x0, y0) {
      x = x0;
      y = y0;
      stepCount = 0;
      resetOptimizerState();

      const f = currentFunction().fn(x, y);
      const g = currentFunction().grad(x, y);
      const gNorm = hypot2(g.gx, g.gy);

      best = { f, x, y };
      trajectory = [{ x, y }];
      lossHistory = [{ f, gNorm }];
      lastUpdate = {
        optimizer: ui().optimizer,
        eta: ui().lr,
        gx: g.gx,
        gy: g.gy,
        gNorm,
        dx: 0,
        dy: 0,
        f0: f,
        f1: f,
        deltaF: 0
      };
    }

    function buildBackground() {
      const fdef = currentFunction();
      const d = fdef.domain;
      const bw = 240;
      const bh = 180;

      bgCanvas = document.createElement('canvas');
      bgCanvas.width = bw;
      bgCanvas.height = bh;
      const bctx = bgCanvas.getContext('2d');
      const img = bctx.createImageData(bw, bh);

      const vals = new Array(bw * bh);
      let k = 0;
      for (let py = 0; py < bh; py += 1) {
        for (let px = 0; px < bw; px += 1) {
          const xv = d.xmin + ((px + 0.5) * (d.xmax - d.xmin)) / bw;
          const yv = d.ymax - ((py + 0.5) * (d.ymax - d.ymin)) / bh;
          vals[k] = Math.max(0, fdef.fn(xv, yv));
          k += 1;
        }
      }

      const sorted = vals.slice().sort((a, b) => a - b);
      const q02 = sorted[Math.floor(sorted.length * 0.02)];
      const q95 = sorted[Math.floor(sorted.length * 0.95)];
      zStats.lMin = Math.log1p(q02);
      zStats.lMax = Math.log1p(q95 + 1e-9);

      k = 0;
      for (let py = 0; py < bh; py += 1) {
        for (let px = 0; px < bw; px += 1) {
          const lv = Math.log1p(vals[k]);
          const t = clamp((lv - zStats.lMin) / Math.max(1e-9, zStats.lMax - zStats.lMin), 0, 1);
          const m = heatRgb(t);
          const idx = (py * bw + px) * 4;
          img.data[idx] = m[0];
          img.data[idx + 1] = m[1];
          img.data[idx + 2] = m[2];
          img.data[idx + 3] = 255;
          k += 1;
        }
      }

      bctx.putImageData(img, 0, 0);
      buildSurfaceMesh();
    }

    function buildSurfaceMesh() {
      const fdef = currentFunction();
      const d = fdef.domain;
      const nx = 30;
      const ny = 30;
      const points = new Array(nx * ny);

      for (let iy = 0; iy < ny; iy += 1) {
        const yv = d.ymin + (iy * (d.ymax - d.ymin)) / (ny - 1);
        for (let ix = 0; ix < nx; ix += 1) {
          const xv = d.xmin + (ix * (d.xmax - d.xmin)) / (nx - 1);
          const zv = fdef.fn(xv, yv);
          points[iy * nx + ix] = { x: xv, y: yv, z: zv };
        }
      }
      surfaceMesh = { nx, ny, points };
    }

    function optimizeOneStep() {
      const s = ui();
      const fdef = currentFunction();
      const d = fdef.domain;

      const f0 = fdef.fn(x, y);
      const g0 = fdef.grad(x, y);
      let gx = g0.gx;
      let gy = g0.gy;

      if (s.noise > 0) {
        gx += randn() * s.noise;
        gy += randn() * s.noise;
      }

      const gNormRaw = hypot2(gx, gy);
      if (s.clip > 0 && gNormRaw > s.clip) {
        const scale = s.clip / gNormRaw;
        gx *= scale;
        gy *= scale;
      }
      const gNorm = hypot2(gx, gy);

      const eta = s.lr / (1 + s.decay * stepCount);
      let dx = 0;
      let dy = 0;

      if (s.optimizer === 'sgd') {
        dx = -eta * gx;
        dy = -eta * gy;
      } else if (s.optimizer === 'momentum') {
        velocity.x = s.beta1 * velocity.x - eta * gx;
        velocity.y = s.beta1 * velocity.y - eta * gy;
        dx = velocity.x;
        dy = velocity.y;
      } else {
        const t = stepCount + 1;
        adam.mx = s.beta1 * adam.mx + (1 - s.beta1) * gx;
        adam.my = s.beta1 * adam.my + (1 - s.beta1) * gy;
        adam.vx = s.beta2 * adam.vx + (1 - s.beta2) * gx * gx;
        adam.vy = s.beta2 * adam.vy + (1 - s.beta2) * gy * gy;

        const mxh = adam.mx / (1 - Math.pow(s.beta1, t));
        const myh = adam.my / (1 - Math.pow(s.beta1, t));
        const vxh = adam.vx / (1 - Math.pow(s.beta2, t));
        const vyh = adam.vy / (1 - Math.pow(s.beta2, t));

        dx = -eta * mxh / (Math.sqrt(vxh) + 1e-8);
        dy = -eta * myh / (Math.sqrt(vyh) + 1e-8);
      }

      const newX = clamp(x + dx, d.xmin, d.xmax);
      const newY = clamp(y + dy, d.ymin, d.ymax);
      const f1 = fdef.fn(newX, newY);

      x = newX;
      y = newY;
      stepCount += 1;

      if (f1 < best.f) {
        best = { f: f1, x, y };
      }

      trajectory.push({ x, y });
      if (trajectory.length > maxTrajectory) {
        trajectory = trajectory.slice(trajectory.length - maxTrajectory);
      }

      const g1 = fdef.grad(x, y);
      const g1Norm = hypot2(g1.gx, g1.gy);
      lossHistory.push({ f: f1, gNorm: g1Norm });
      if (lossHistory.length > maxHistory) {
        lossHistory = lossHistory.slice(lossHistory.length - maxHistory);
      }

      lastUpdate = {
        optimizer: s.optimizer,
        eta,
        gx,
        gy,
        gNorm,
        dx,
        dy,
        f0,
        f1,
        deltaF: f1 - f0
      };
    }

    function statusMessage() {
      if (!lastUpdate) {
        return { level: 'warn', text: '初期化中です。' };
      }
      if (lastUpdate.f1 > 1e6 || !Number.isFinite(lastUpdate.f1)) {
        return {
          level: 'bad',
          text: '発散の可能性があります。学習率を下げるか勾配クリップを強めてください。'
        };
      }
      if (lastUpdate.gNorm < 1e-3) {
        return {
          level: 'good',
          text: '勾配ノルムが十分小さく、収束に近い状態です。'
        };
      }
      if (lastUpdate.deltaF > 0) {
        return {
          level: 'warn',
          text: '直前ステップで損失が増加しました。ηやβを調整してみてください。'
        };
      }
      return {
        level: 'good',
        text: '損失が低下中です。軌跡と更新ベクトルを見て挙動を確認してください。'
      };
    }

    function drawPlot() {
      const w = plot.width;
      const h = plot.height;
      const pad = 56;
      const d = currentFunction().domain;

      const x2px = xv => pad + ((xv - d.xmin) * (w - 2 * pad)) / (d.xmax - d.xmin);
      const y2py = yv => h - pad - ((yv - d.ymin) * (h - 2 * pad)) / (d.ymax - d.ymin);

      pctx.clearRect(0, 0, w, h);
      pctx.fillStyle = 'rgba(7,14,30,0.55)';
      pctx.fillRect(pad, pad, w - 2 * pad, h - 2 * pad);

      if (bgCanvas) {
        pctx.drawImage(bgCanvas, pad, pad, w - 2 * pad, h - 2 * pad);
      }

      pctx.strokeStyle = 'rgba(255,255,255,0.11)';
      pctx.lineWidth = 1;
      for (let i = 0; i <= 8; i += 1) {
        const tx = d.xmin + (i * (d.xmax - d.xmin)) / 8;
        pctx.beginPath();
        pctx.moveTo(x2px(tx), y2py(d.ymin));
        pctx.lineTo(x2px(tx), y2py(d.ymax));
        pctx.stroke();
      }
      for (let i = 0; i <= 8; i += 1) {
        const ty = d.ymin + (i * (d.ymax - d.ymin)) / 8;
        pctx.beginPath();
        pctx.moveTo(x2px(d.xmin), y2py(ty));
        pctx.lineTo(x2px(d.xmax), y2py(ty));
        pctx.stroke();
      }

      pctx.strokeStyle = 'rgba(255,255,255,0.35)';
      pctx.lineWidth = 1.2;
      if (d.xmin <= 0 && d.xmax >= 0) {
        pctx.beginPath();
        pctx.moveTo(x2px(0), y2py(d.ymin));
        pctx.lineTo(x2px(0), y2py(d.ymax));
        pctx.stroke();
      }
      if (d.ymin <= 0 && d.ymax >= 0) {
        pctx.beginPath();
        pctx.moveTo(x2px(d.xmin), y2py(0));
        pctx.lineTo(x2px(d.xmax), y2py(0));
        pctx.stroke();
      }

      const optima = currentFunction().optima;
      for (const o of optima) {
        const ox = x2px(o.x);
        const oy = y2py(o.y);
        pctx.strokeStyle = 'rgba(111,223,167,0.95)';
        pctx.lineWidth = 2;
        pctx.beginPath();
        pctx.moveTo(ox - 5, oy);
        pctx.lineTo(ox + 5, oy);
        pctx.stroke();
        pctx.beginPath();
        pctx.moveTo(ox, oy - 5);
        pctx.lineTo(ox, oy + 5);
        pctx.stroke();
      }

      if (trajectory.length >= 2) {
        pctx.strokeStyle = 'rgba(255,225,120,0.96)';
        pctx.lineWidth = 2.2;
        pctx.beginPath();
        pctx.moveTo(x2px(trajectory[0].x), y2py(trajectory[0].y));
        for (let i = 1; i < trajectory.length; i += 1) {
          pctx.lineTo(x2px(trajectory[i].x), y2py(trajectory[i].y));
        }
        pctx.stroke();
      }

      const cx = x2px(x);
      const cy = y2py(y);
      pctx.fillStyle = 'rgba(255,142,142,0.97)';
      pctx.beginPath();
      pctx.arc(cx, cy, 5.5, 0, Math.PI * 2);
      pctx.fill();

      if (lastUpdate) {
        const domainScale = 0.18 * Math.min(d.xmax - d.xmin, d.ymax - d.ymin) / Math.max(1e-8, lastUpdate.gNorm);
        const gxTo = x + lastUpdate.gx * domainScale;
        const gyTo = y + lastUpdate.gy * domainScale;
        drawArrow(pctx, cx, cy, x2px(gxTo), y2py(gyTo), 'rgba(255,148,189,0.95)', 2);

        const uxTo = x + lastUpdate.dx * 3.5;
        const uyTo = y + lastUpdate.dy * 3.5;
        drawArrow(pctx, cx, cy, x2px(uxTo), y2py(uyTo), 'rgba(127,214,255,0.95)', 2);
      }

      pctx.fillStyle = 'rgba(230,237,255,0.9)';
      pctx.font = '12px "Hiragino Sans", sans-serif';
      pctx.fillText(`x:[${d.xmin.toFixed(1)}, ${d.xmax.toFixed(1)}], y:[${d.ymin.toFixed(1)}, ${d.ymax.toFixed(1)}]`, x2px(d.xmin), h - 20);
    }

    function drawSurface3D() {
      const w = surfacePlot.width;
      const h = surfacePlot.height;
      const pad = 20;
      const d = currentFunction().domain;
      const s = ui();

      sctx.clearRect(0, 0, w, h);
      sctx.fillStyle = 'rgba(7,14,30,0.55)';
      sctx.fillRect(pad, pad, w - 2 * pad, h - 2 * pad);

      if (!surfaceMesh) return;

      const view = {
        azimuth: s.azimuth,
        elevation: s.elevation,
        cx: w * 0.5,
        cy: h * 0.58
      };

      const { nx, ny, points } = surfaceMesh;
      const proj = new Array(points.length);
      const tVals = new Array(points.length);

      for (let i = 0; i < points.length; i += 1) {
        const p = points[i];
        const world = toWorld(p.x, p.y, p.z, d, s.zScale);
        proj[i] = project3D(world.wx, world.wy, world.wz, view);
        tVals[i] = zToUnit(p.z);
      }

      const faces = [];
      for (let iy = 0; iy < ny - 1; iy += 1) {
        for (let ix = 0; ix < nx - 1; ix += 1) {
          const i00 = iy * nx + ix;
          const i10 = iy * nx + ix + 1;
          const i01 = (iy + 1) * nx + ix;
          const i11 = (iy + 1) * nx + ix + 1;
          const depth = (proj[i00].depth + proj[i10].depth + proj[i01].depth + proj[i11].depth) / 4;
          const t = (tVals[i00] + tVals[i10] + tVals[i01] + tVals[i11]) / 4;
          faces.push({ i00, i10, i01, i11, depth, t });
        }
      }
      faces.sort((a, b) => b.depth - a.depth);

      for (const f of faces) {
        const p00 = proj[f.i00];
        const p10 = proj[f.i10];
        const p01 = proj[f.i01];
        const p11 = proj[f.i11];

        sctx.fillStyle = heatColorA(f.t, 0.19);
        sctx.beginPath();
        sctx.moveTo(p00.sx, p00.sy);
        sctx.lineTo(p10.sx, p10.sy);
        sctx.lineTo(p11.sx, p11.sy);
        sctx.lineTo(p01.sx, p01.sy);
        sctx.closePath();
        sctx.fill();
      }

      sctx.strokeStyle = 'rgba(255,255,255,0.22)';
      sctx.lineWidth = 0.8;
      for (let iy = 0; iy < ny; iy += 1) {
        sctx.beginPath();
        for (let ix = 0; ix < nx; ix += 1) {
          const p = proj[iy * nx + ix];
          if (ix === 0) sctx.moveTo(p.sx, p.sy);
          else sctx.lineTo(p.sx, p.sy);
        }
        sctx.stroke();
      }
      for (let ix = 0; ix < nx; ix += 1) {
        sctx.beginPath();
        for (let iy = 0; iy < ny; iy += 1) {
          const p = proj[iy * nx + ix];
          if (iy === 0) sctx.moveTo(p.sx, p.sy);
          else sctx.lineTo(p.sx, p.sy);
        }
        sctx.stroke();
      }

      function projectPointOnSurface(xv, yv) {
        const zv = currentFunction().fn(xv, yv);
        const world = toWorld(xv, yv, zv, d, s.zScale);
        return project3D(world.wx, world.wy, world.wz, view);
      }

      const trailStart = Math.max(0, trajectory.length - 300);
      if (trajectory.length - trailStart >= 2) {
        sctx.strokeStyle = 'rgba(255,225,120,0.95)';
        sctx.lineWidth = 2;
        sctx.beginPath();
        for (let i = trailStart; i < trajectory.length; i += 1) {
          const pt = projectPointOnSurface(trajectory[i].x, trajectory[i].y);
          if (i === trailStart) sctx.moveTo(pt.sx, pt.sy);
          else sctx.lineTo(pt.sx, pt.sy);
        }
        sctx.stroke();
      }

      for (const o of currentFunction().optima) {
        const po = projectPointOnSurface(o.x, o.y);
        sctx.strokeStyle = 'rgba(111,223,167,0.96)';
        sctx.lineWidth = 2;
        sctx.beginPath();
        sctx.moveTo(po.sx - 4, po.sy);
        sctx.lineTo(po.sx + 4, po.sy);
        sctx.stroke();
        sctx.beginPath();
        sctx.moveTo(po.sx, po.sy - 4);
        sctx.lineTo(po.sx, po.sy + 4);
        sctx.stroke();
      }

      const cp = projectPointOnSurface(x, y);
      sctx.fillStyle = 'rgba(255,142,142,0.98)';
      sctx.beginPath();
      sctx.arc(cp.sx, cp.sy, 5.2, 0, Math.PI * 2);
      sctx.fill();

      sctx.fillStyle = 'rgba(230,237,255,0.88)';
      sctx.font = '12px "Hiragino Sans", sans-serif';
      sctx.fillText(`az=${(s.azimuth * 180 / Math.PI).toFixed(0)}°, el=${(s.elevation * 180 / Math.PI).toFixed(0)}°, z-scale=${s.zScale.toFixed(2)}`, pad + 6, h - 12);
    }

    function drawLoss() {
      const w = lossPlot.width;
      const h = lossPlot.height;
      const pad = 42;

      lctx.clearRect(0, 0, w, h);
      lctx.fillStyle = 'rgba(7,14,30,0.55)';
      lctx.fillRect(pad, 16, w - 2 * pad, h - 30);

      if (lossHistory.length < 2) {
        lctx.fillStyle = 'rgba(225,233,255,0.82)';
        lctx.font = '12px "Hiragino Sans", sans-serif';
        lctx.fillText('ステップを進めると f(x,y) と ||∇f|| の推移が表示されます。', pad + 8, 38);
        return;
      }

      const values = [];
      for (const e of lossHistory) {
        values.push(Math.log10(e.f + 1e-8), Math.log10(e.gNorm + 1e-8));
      }
      const yMin = Math.min(...values);
      const yMax = Math.max(...values);
      const ySpan = Math.max(0.4, yMax - yMin);

      const x2px = i => pad + (i * (w - 2 * pad)) / (lossHistory.length - 1);
      const y2py = v => (h - 14) - ((v - yMin) * (h - 34)) / ySpan;

      lctx.strokeStyle = 'rgba(255,255,255,0.12)';
      lctx.lineWidth = 1;
      for (let i = 0; i <= 4; i += 1) {
        const yy = yMin + (i * ySpan) / 4;
        lctx.beginPath();
        lctx.moveTo(pad, y2py(yy));
        lctx.lineTo(w - pad, y2py(yy));
        lctx.stroke();
      }

      function drawLine(getter, color) {
        lctx.strokeStyle = color;
        lctx.lineWidth = 2;
        lctx.beginPath();
        for (let i = 0; i < lossHistory.length; i += 1) {
          const yv = Math.log10(getter(lossHistory[i]) + 1e-8);
          if (i === 0) lctx.moveTo(x2px(i), y2py(yv));
          else lctx.lineTo(x2px(i), y2py(yv));
        }
        lctx.stroke();
      }

      drawLine(v => v.f, 'rgba(255,217,116,0.98)');
      drawLine(v => v.gNorm, 'rgba(159,200,255,0.95)');

      lctx.fillStyle = 'rgba(230,237,255,0.88)';
      lctx.font = '11px "Hiragino Sans", sans-serif';
      lctx.fillText('log10(f)', pad + 8, 28);
      lctx.fillText('log10(||∇f||)', pad + 64, 28);
      lctx.fillText(`最新: f=${lossHistory[lossHistory.length - 1].f.toFixed(5)} / ||∇f||=${lossHistory[lossHistory.length - 1].gNorm.toFixed(5)}`, pad + 8, h - 8);
    }

    function updateUI() {
      const s = ui();

      document.getElementById('lrVal').textContent = s.lr.toFixed(4);
      document.getElementById('decayVal').textContent = s.decay.toFixed(3);
      document.getElementById('beta1Val').textContent = s.beta1.toFixed(2);
      document.getElementById('beta2Val').textContent = s.beta2.toFixed(3);
      document.getElementById('clipVal').textContent = s.clip.toFixed(2);
      document.getElementById('noiseVal').textContent = s.noise.toFixed(2);
      document.getElementById('speedVal').textContent = `${s.speed}`;
      document.getElementById('azVal').textContent = `${(s.azimuth * 180 / Math.PI).toFixed(0)}°`;
      document.getElementById('elVal').textContent = `${(s.elevation * 180 / Math.PI).toFixed(0)}°`;
      document.getElementById('zScaleVal').textContent = s.zScale.toFixed(2);
      document.getElementById('startXVal').textContent = parseFloat(startXRange.value).toFixed(2);
      document.getElementById('startYVal').textContent = parseFloat(startYRange.value).toFixed(2);

      document.getElementById('modePill').textContent = running ? 'モード: 学習中' : 'モード: 停止中';
      document.getElementById('statePill').textContent = running ? '状態: 計算中' : '状態: 一時停止';

      const currentF = currentFunction().fn(x, y);
      const g = currentFunction().grad(x, y);
      const gNorm = hypot2(g.gx, g.gy);

      document.getElementById('stepVal').textContent = `${stepCount}`;
      document.getElementById('fNowVal').textContent = currentF.toFixed(6);
      document.getElementById('gNormVal').textContent = gNorm.toFixed(6);
      document.getElementById('xyNowVal').textContent = `(${x.toFixed(4)}, ${y.toFixed(4)})`;
      document.getElementById('bestVal').textContent = best.f.toFixed(6);
      document.getElementById('bestXYVal').textContent = `(${best.x.toFixed(4)}, ${best.y.toFixed(4)})`;
      document.getElementById('etaVal').textContent = (s.lr / (1 + s.decay * stepCount)).toFixed(6);
      document.getElementById('deltaFVal').textContent = lastUpdate ? lastUpdate.deltaF.toFixed(6) : '-';
      document.getElementById('moveVal').textContent = lastUpdate ? hypot2(lastUpdate.dx, lastUpdate.dy).toFixed(6) : '-';

      const st = statusMessage();
      const statusBox = document.getElementById('statusBox');
      statusBox.className = `status ${st.level}`;
      statusBox.textContent = `評価: ${st.text}`;

      const detail = [];
      detail.push(`function: ${currentFunction().label}`);
      detail.push(`equation: ${currentFunction().equation}`);
      detail.push(`optimizer: ${s.optimizer}`);
      detail.push(`x=${x.toFixed(6)}, y=${y.toFixed(6)}`);
      detail.push(`f(x,y)=${currentF.toFixed(8)}`);
      detail.push(`grad=(${g.gx.toFixed(6)}, ${g.gy.toFixed(6)}), ||grad||=${gNorm.toFixed(6)}`);
      if (lastUpdate) {
        detail.push(`eta_t=${lastUpdate.eta.toFixed(8)}`);
        detail.push(`update=(${lastUpdate.dx.toFixed(6)}, ${lastUpdate.dy.toFixed(6)})`);
        detail.push(`delta_f=${lastUpdate.deltaF.toFixed(8)}`);
      }
      detail.push(`known optima: ${currentFunction().optima.map(o => `(${o.x.toFixed(3)},${o.y.toFixed(3)})`).join(', ')}`);
      document.getElementById('detailBox').textContent = detail.join('\n');

      beta1Range.disabled = s.optimizer === 'sgd';
      beta2Range.disabled = s.optimizer !== 'adam';
    }

    function resetForCurrentFunction(useRandomStart) {
      setStartSliderRange();
      if (useRandomStart) {
        const r = randomStartPoint();
        setStartSliders(r.x, r.y);
      } else {
        const st = currentFunction().start;
        setStartSliders(st.x, st.y);
      }
      buildBackground();
      const st = currentStart();
      softReset(st.x, st.y);
    }

    function resetWithSliderStart() {
      const st = currentStart();
      softReset(st.x, st.y);
    }

    function frame(now) {
      const dt = now - lastT;
      lastT = now;

      if (running) {
        accMs += dt;
        const interval = 1000 / Math.max(1, ui().speed);
        let guard = 0;
        while (accMs >= interval && guard < 360) {
          optimizeOneStep();
          accMs -= interval;
          guard += 1;
        }
      } else {
        accMs = 0;
      }

      drawPlot();
      drawSurface3D();
      drawLoss();
      updateUI();
      requestAnimationFrame(frame);
    }

    document.getElementById('btnPlay').addEventListener('click', () => {
      running = true;
    });

    document.getElementById('btnPause').addEventListener('click', () => {
      running = false;
    });

    document.getElementById('btnStep').addEventListener('click', () => {
      running = false;
      optimizeOneStep();
    });

    document.getElementById('btnReset').addEventListener('click', () => {
      running = false;
      resetWithSliderStart();
    });

    document.getElementById('btnRandom').addEventListener('click', () => {
      running = false;
      const r = randomStartPoint();
      setStartSliders(r.x, r.y);
      resetWithSliderStart();
    });

    fnSelect.addEventListener('change', () => {
      running = false;
      resetForCurrentFunction(false);
    });

    optSelect.addEventListener('change', () => {
      running = false;
      resetWithSliderStart();
    });

    startXRange.addEventListener('input', () => {
      document.getElementById('startXVal').textContent = parseFloat(startXRange.value).toFixed(2);
    });

    startYRange.addEventListener('input', () => {
      document.getElementById('startYVal').textContent = parseFloat(startYRange.value).toFixed(2);
    });

    startXRange.addEventListener('change', () => {
      running = false;
      resetWithSliderStart();
    });

    startYRange.addEventListener('change', () => {
      running = false;
      resetWithSliderStart();
    });

    for (const s of sliders) {
      s.addEventListener('input', updateUI);
    }

    resetForCurrentFunction(false);
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
